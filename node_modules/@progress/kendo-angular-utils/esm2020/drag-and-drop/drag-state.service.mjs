/**-----------------------------------------------------------------------------------------
* Copyright © 2024 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Injectable } from '@angular/core';
import { dispatchDragAndDrop, getScrollableParent, autoScroll } from '@progress/kendo-draggable-common';
import { isPresent } from './util';
import * as i0 from "@angular/core";
/**
 * @hidden
 */
export class DragStateService {
    constructor() {
        this.dragTarget = null;
        this.dropTarget = null;
        this.dragTargets = [];
        this.dropTargets = [];
        this.pressed = false;
        this.ignoreMouse = false;
        this.autoScroll = true;
        this.isScrolling = false;
        this.scrollableParent = null;
        this.autoScrollDirection = { horizontal: true, vertical: true };
        this.initialClientOffset = { x: 0, y: 0 };
        this.clientOffset = { x: 0, y: 0 };
        this.initialScrollOffset = { x: 0, y: 0 };
        this.scrollOffset = { x: 0, y: 0 };
        this.offset = { x: 0, y: 0 };
        this.pageOffset = { x: 0, y: 0 };
        this.velocity = { x: 0, y: 0 };
        this.dragIndex = null;
        this.dropIndex = null;
        this.callbacks = {};
        this.scrollInterval = null;
        this.setCallbacks();
    }
    handleDragAndDrop(action) {
        this.updateState();
        dispatchDragAndDrop(this.state, action, this.callbacks);
    }
    setPressed(pressed) {
        this.pressed = pressed;
    }
    setScrolling(isScrolling) {
        this.isScrolling = isScrolling;
        if (isScrolling) {
            const scrollableParent = getScrollableParent(document.elementFromPoint(this.clientOffset.x, this.clientOffset.y));
            window.clearInterval(this.scrollInterval);
            this.scrollInterval = window.setInterval(() => {
                autoScroll(scrollableParent, { x: this.velocity.x, y: this.velocity.y });
            }, 50);
        }
        else {
            if (this.scrollInterval) {
                window.clearInterval(this.scrollInterval);
                this.scrollInterval = null;
            }
        }
    }
    setVelocity(velocity) {
        this.velocity = velocity;
    }
    setOffset(offset) {
        this.offset = offset;
    }
    setClientOffset(clientOffset) {
        this.clientOffset = clientOffset;
    }
    setPageOffset(pageOffset) {
        this.pageOffset = pageOffset;
    }
    setInitialClientOffset(initialClientOffset) {
        this.initialClientOffset = initialClientOffset;
    }
    setScrollOffset(scrollOffset) {
        this.scrollOffset = scrollOffset;
    }
    setInitialScrollOffset(initialScrollOffset) {
        this.initialScrollOffset = initialScrollOffset;
    }
    get dragTargetPresent() {
        return isPresent(this.dragTarget?.element);
    }
    get dropTargetPresent() {
        return isPresent(this.dropTarget?.element);
    }
    updateState() {
        this.state = {
            drag: this.dragTarget,
            drop: this.dropTarget,
            drags: this.dragTargets,
            drops: this.dropTargets,
            pressed: this.pressed,
            ignoreMouse: this.ignoreMouse,
            autoScroll: this.autoScroll,
            isScrolling: this.isScrolling,
            scrollableParent: this.scrollableParent,
            autoScrollDirection: this.autoScrollDirection,
            initialClientOffset: this.initialClientOffset,
            clientOffset: this.clientOffset,
            initialScrollOffset: this.initialScrollOffset,
            scrollOffset: this.scrollOffset,
            offset: this.offset,
            pageOffset: this.pageOffset,
            velocity: this.velocity
        };
    }
    setCallbacks() {
        this.callbacks = {
            onVelocityChange: this.setVelocity.bind(this),
            onOffsetChange: this.setOffset.bind(this),
            onClientOffsetChange: this.setClientOffset.bind(this),
            onPageOffsetChange: this.setPageOffset.bind(this),
            onInitialClientOffsetChange: this.setInitialClientOffset.bind(this),
            onScrollOffsetChange: this.setScrollOffset.bind(this),
            onInitialScrollOffsetChange: this.setInitialScrollOffset.bind(this),
            onIsPressedChange: this.setPressed.bind(this),
            onIsScrollingChange: this.setScrolling.bind(this)
        };
    }
    ngOnDestroy() {
        if (this.scrollInterval) {
            window.clearInterval(this.scrollInterval);
            this.scrollInterval = null;
        }
    }
}
DragStateService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: DragStateService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
DragStateService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: DragStateService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: DragStateService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });
