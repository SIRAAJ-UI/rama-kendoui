/**-----------------------------------------------------------------------------------------
* Copyright © 2024 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Component, HostBinding, Input, ElementRef, NgZone, Renderer2, Output, EventEmitter, ViewChild, ViewChildren, QueryList } from '@angular/core';
import { ColumnMenuService } from './column-menu.service';
import { ColumnListKeyboardNavigation } from './column-list-kb-nav.service';
import { ColumnMenuChooserItemCheckedDirective } from './column-chooser-item-checked.directive';
import { Keys } from '@progress/kendo-angular-common';
import { Subscription } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "./column-list-kb-nav.service";
import * as i2 from "@angular/common";
import * as i3 from "./column-chooser-item-checked.directive";
/**
 * @hidden
 */
export class ColumnListComponent {
    constructor(element, ngZone, renderer, listNavigationService) {
        this.element = element;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.listNavigationService = listNavigationService;
        this.reset = new EventEmitter();
        this.apply = new EventEmitter();
        this.columnChange = new EventEmitter();
        this.autoSync = true;
        this.allowHideAll = false;
        this.actionsClass = 'k-actions k-actions-stretched k-actions-horizontal';
        this.unlockedCount = 0;
        this.domSubscriptions = new Subscription();
        this.onKeydown = (e) => {
            if (e.keyCode !== Keys.Tab) {
                e.preventDefault();
            }
            if (e.keyCode === Keys.ArrowDown) {
                this.listNavigationService.next();
            }
            else if (e.keyCode === Keys.ArrowUp) {
                this.listNavigationService.prev();
            }
            else if (e.keyCode === Keys.Space && e.target.classList.contains('k-column-list-item')) {
                this.listNavigationService.toggleCheckedState();
            }
        };
    }
    get className() {
        return true;
    }
    isChecked(checkbox) {
        return checkbox.checked;
    }
    set columns(value) {
        this._columns = value.filter(column => column.includeInChooser !== false);
        this.allColumns = value;
        this.updateColumnState();
    }
    get columns() {
        return this._columns;
    }
    ngOnInit() {
        if (!this.element) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            this.domSubscriptions.add(this.renderer.listen(this.element.nativeElement, 'click', (e) => {
                const closestItem = e.target.closest('.k-column-list-item');
                if (closestItem) {
                    const checkbox = closestItem.querySelector('.k-checkbox');
                    const index = parseInt(checkbox.getAttribute('data-index'), 10);
                    if (e.target === checkbox) {
                        closestItem.focus();
                    }
                    else {
                        e.preventDefault();
                        checkbox.checked = !checkbox.checked;
                    }
                    if (this.autoSync) {
                        const column = this.columns[index];
                        const hidden = !checkbox.checked;
                        if (Boolean(column.hidden) !== hidden) {
                            this.ngZone.run(() => {
                                column.hidden = hidden;
                                this.columnChange.emit([column]);
                            });
                        }
                    }
                    else {
                        this.updateDisabled();
                    }
                    if (index !== this.listNavigationService.activeIndex) {
                        this.listNavigationService.toggle(this.listNavigationService.activeIndex, false);
                        this.listNavigationService.activeIndex = index;
                        this.listNavigationService.toggle(index, true);
                    }
                }
            }));
            this.domSubscriptions.add(this.renderer.listen(this.element.nativeElement, 'keydown', this.onKeydown));
        });
    }
    ngAfterViewInit() {
        this.listNavigationService.items = this.options.toArray();
        this.listNavigationService.toggle(0, true);
        this.updateDisabled();
    }
    ngOnChanges(changes) {
        if (!this.service) {
            return;
        }
        if (changes['isLast'] && this.isLast) {
            this.service.menuTabbingService.lastFocusable = this.applyButton.nativeElement;
        }
        if (changes['isExpanded'] && this.isExpanded && this.isLast && this.applyButton) {
            this.service.menuTabbingService.lastFocusable = this.applyButton.nativeElement;
        }
    }
    ngOnDestroy() {
        this.domSubscriptions.unsubscribe();
    }
    isDisabled(column) {
        return !(this.allowHideAll || this.hasFiltered || column.hidden || this.columns.find(current => current !== column && !current.hidden)) ||
            (this.hasVisibleLocked && !this.hasUnlockedFiltered && this.unlockedCount === 1 && !column.locked && !column.hidden);
    }
    cancelChanges() {
        this.forEachCheckBox((element, index) => {
            element.checked = !this.columns[index].hidden;
        });
        this.updateDisabled();
        this.reset.emit();
    }
    applyChanges() {
        const changed = [];
        this.forEachCheckBox((element, index) => {
            const column = this.columns[index];
            const hidden = !element.checked;
            if (Boolean(column.hidden) !== hidden) {
                column.hidden = hidden;
                changed.push(column);
            }
        });
        this.updateDisabled();
        this.apply.emit(changed);
    }
    onTab(e) {
        if (this.isLast) {
            e.preventDefault();
            if (this.service) {
                this.service.menuTabbingService.firstFocusable.focus();
            }
            else {
                this.listNavigationService.toggle(this.listNavigationService.activeIndex, true);
            }
        }
    }
    forEachCheckBox(callback) {
        const checkboxes = this.element.nativeElement.getElementsByClassName('k-checkbox');
        const length = checkboxes.length;
        for (let idx = 0; idx < length; idx++) {
            callback(checkboxes[idx], idx);
        }
    }
    updateDisabled() {
        if (this.allowHideAll && !this.hasLocked) {
            return;
        }
        const checkedItems = [];
        this.forEachCheckBox((checkbox, index) => {
            if (checkbox.checked) {
                checkedItems.push({ checkbox, index });
            }
            this.setDisabledState(checkbox, false);
        });
        if (!this.allowHideAll && checkedItems.length === 1 && !this.hasFiltered) {
            this.setDisabledState(checkedItems[0].checkbox, true);
        }
        else if (this.hasLocked && !this.hasUnlockedFiltered) {
            const columns = this.columns;
            const checkedUnlocked = checkedItems.filter(item => !columns[item.index].locked);
            if (checkedUnlocked.length === 1) {
                this.setDisabledState(checkedUnlocked[0].checkbox, true);
            }
        }
    }
    updateColumnState() {
        this.hasLocked = this.allColumns.filter(column => column.locked && (!column.hidden || column.includeInChooser !== false)).length > 0;
        this.hasVisibleLocked = this.allColumns.filter(column => column.locked && !column.hidden).length > 0;
        this.unlockedCount = this.columns.filter(column => !column.locked && !column.hidden).length;
        const filteredColumns = this.allColumns.filter(column => column.includeInChooser === false && !column.hidden);
        if (filteredColumns.length) {
            this.hasFiltered = filteredColumns.length > 0;
            this.hasUnlockedFiltered = filteredColumns.filter(column => !column.locked).length > 0;
        }
        else {
            this.hasFiltered = false;
            this.hasUnlockedFiltered = false;
        }
    }
    setDisabledState(element, disabled) {
        element.disabled = disabled;
        const parent = element.parentElement;
        const classCommand = disabled ? 'addClass' : 'removeClass';
        const attributeCommand = disabled ? 'setAttribute' : 'removeAttribute';
        this.renderer[classCommand](parent, 'k-disabled');
        this.renderer[attributeCommand](parent, 'aria-disabled', disabled ? 'true' : undefined);
    }
}
ColumnListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ColumnListComponent, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i1.ColumnListKeyboardNavigation }], target: i0.ɵɵFactoryTarget.Component });
ColumnListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: ColumnListComponent, selector: "kendo-grid-columnlist", inputs: { columns: "columns", autoSync: "autoSync", ariaLabel: "ariaLabel", allowHideAll: "allowHideAll", applyText: "applyText", resetText: "resetText", actionsClass: "actionsClass", isLast: "isLast", isExpanded: "isExpanded", service: "service" }, outputs: { reset: "reset", apply: "apply", columnChange: "columnChange" }, host: { properties: { "class.k-column-list-wrapper": "this.className" } }, providers: [ColumnListKeyboardNavigation], viewQueries: [{ propertyName: "resetButton", first: true, predicate: ["resetButton"], descendants: true }, { propertyName: "applyButton", first: true, predicate: ["applyButton"], descendants: true }, { propertyName: "options", predicate: ColumnMenuChooserItemCheckedDirective, descendants: true }], usesOnChanges: true, ngImport: i0, template: `
        <div 
            class="k-column-list"
            role="listbox"
            aria-multiselectable="true"
            [attr.aria-label]="ariaLabel">
            <label 
                *ngFor="let column of columns; let index = index;" 
                class='k-column-list-item'
                [kendoColumnMenuChooserItemChecked]="!column.hidden"
                role="option">
                <input 
                    class="k-checkbox k-checkbox-md k-rounded-md" 
                    type="checkbox" 
                    [attr.data-index]="index"
                    [checked]="!column.hidden" 
                    tabindex="-1"
                    [attr.aria-hidden]="true"
                    [disabled]="isDisabled(column)" />
                <span class="k-checkbox-label">{{ column.displayTitle }}</span>
            </label>
        </div>
        <div [ngClass]="actionsClass" *ngIf="!autoSync">
            <button
                #applyButton
                type="button"
                class="k-button k-button-solid-primary k-button-solid k-button-md k-rounded-md k-button-rectangle"
                (click)="applyChanges()"
                (keydown.enter)="$event.preventDefault(); $event.stopPropagation; applyChanges();"
                (keydown.space)="$event.preventDefault(); $event.stopPropagation; applyChanges();">{{ applyText }}</button>
            <button
                #resetButton
                type="button"
                (keydown.tab)="onTab($event)"
                class="k-button k-button-solid-base k-button-solid k-button-md k-rounded-md k-button-rectangle"
                (click)="cancelChanges()"
                (keydown.enter)="$event.preventDefault(); $event.stopPropagation; cancelChanges();"
                (keydown.space)="$event.preventDefault(); $event.stopPropagation; cancelChanges();">{{ resetText }}</button>
        </div>
    `, isInline: true, directives: [{ type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.ColumnMenuChooserItemCheckedDirective, selector: "[kendoColumnMenuChooserItemChecked]", inputs: ["kendoColumnMenuChooserItemChecked"] }, { type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: ColumnListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-grid-columnlist',
                    providers: [ColumnListKeyboardNavigation],
                    template: `
        <div 
            class="k-column-list"
            role="listbox"
            aria-multiselectable="true"
            [attr.aria-label]="ariaLabel">
            <label 
                *ngFor="let column of columns; let index = index;" 
                class='k-column-list-item'
                [kendoColumnMenuChooserItemChecked]="!column.hidden"
                role="option">
                <input 
                    class="k-checkbox k-checkbox-md k-rounded-md" 
                    type="checkbox" 
                    [attr.data-index]="index"
                    [checked]="!column.hidden" 
                    tabindex="-1"
                    [attr.aria-hidden]="true"
                    [disabled]="isDisabled(column)" />
                <span class="k-checkbox-label">{{ column.displayTitle }}</span>
            </label>
        </div>
        <div [ngClass]="actionsClass" *ngIf="!autoSync">
            <button
                #applyButton
                type="button"
                class="k-button k-button-solid-primary k-button-solid k-button-md k-rounded-md k-button-rectangle"
                (click)="applyChanges()"
                (keydown.enter)="$event.preventDefault(); $event.stopPropagation; applyChanges();"
                (keydown.space)="$event.preventDefault(); $event.stopPropagation; applyChanges();">{{ applyText }}</button>
            <button
                #resetButton
                type="button"
                (keydown.tab)="onTab($event)"
                class="k-button k-button-solid-base k-button-solid k-button-md k-rounded-md k-button-rectangle"
                (click)="cancelChanges()"
                (keydown.enter)="$event.preventDefault(); $event.stopPropagation; cancelChanges();"
                (keydown.space)="$event.preventDefault(); $event.stopPropagation; cancelChanges();">{{ resetText }}</button>
        </div>
    `
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i1.ColumnListKeyboardNavigation }]; }, propDecorators: { className: [{
                type: HostBinding,
                args: ["class.k-column-list-wrapper"]
            }], reset: [{
                type: Output
            }], apply: [{
                type: Output
            }], columnChange: [{
                type: Output
            }], columns: [{
                type: Input
            }], autoSync: [{
                type: Input
            }], ariaLabel: [{
                type: Input
            }], allowHideAll: [{
                type: Input
            }], applyText: [{
                type: Input
            }], resetText: [{
                type: Input
            }], actionsClass: [{
                type: Input
            }], isLast: [{
                type: Input
            }], isExpanded: [{
                type: Input
            }], service: [{
                type: Input
            }], resetButton: [{
                type: ViewChild,
                args: ['resetButton', { static: false }]
            }], applyButton: [{
                type: ViewChild,
                args: ['applyButton', { static: false }]
            }], options: [{
                type: ViewChildren,
                args: [ColumnMenuChooserItemCheckedDirective]
            }] } });
